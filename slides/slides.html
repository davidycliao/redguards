<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>slides.utf8</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.6/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/metropolis-fonts.css" rel="stylesheet" />
    <link rel="stylesheet" href="my-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# <span style='font-size: 40px'> .hi-grey[Factionalism and the Red Guards under the Cultural Revolution]
</style>
## <span style='font-size: 28px'>.hi-slate[Ideal Point Estimation Using Text-as-Data Scaling Method]
</style>
### <span style='font-size: 20px'> Yi-Nung Tsai (NCCU),Dechun Zhang (Leiden), and David, Yen-Chieh Liao (Essex)
</style>

---


exclude: true







---
layout: true
# Research Questions
---
name:research_questions

&amp;nbsp;

-  The main question of our interest is the overall .hi-slate[ideological dissimilarity] between the political elite and the Red Guards: if overall, the political elite placed themselves differently vis-à-vis the Red Guards along the spectrum of ideological positions. 

--

- Secondly, we study, at .hi-slate[the time interval of each major incident], the degree of disagreement among different factions in the Red Guards and investigate its spatial positioning in correspond to the political elite.

---
layout: true
# The Puzzles
---

&amp;nbsp;

- The literature has well explained how activists of the mass movement (the Red Guards) .hi-slate[were divided into multiple factions] that fought for controls for ruling power, political resources and other interests, such as educational institutes, workplaces, and local governments, etc. (e.g.Walder and Su 2003; Walder 2009).


--

- However, how different factions among the Red Guards .hi-slate[selected positions of their own, or stances towards allies and against rivalries, or attitudes towards the political elite], during the mass movement remains relatively untouched.

---
layout: true
# Backgroud
---
name:background

### Historical Backgroud

- The mass movement initiated by commoners during the Cultural Revolution set off as a comprehensive attack on the system of bureaucracy, where the major political power was firmly grasped by the elite. 

--

- For a period, Mao Zedong (毛澤東) and his central leadership were .hi-slate[dis-supportive] to plans that involved forming associations and groups independent from the Party and condemned any unauthorized action by the mass to remove politicians from their office.

--

- However, later on, Mao's attitude became so shifted that he .hi-slate[openly endorsed] and authorized the mass movement and .hi-slate[even encouraged students into participation], without legal or political restriction imposed.

---

### The Origin of Red Guards:

- First of all, .hi-slate[aims and scopes of “the Red Guards”], for Mao and the Central Cultural Revolution Group (CCRG), could be shaped accordingly to fulfill their needs along with the evolvement of the movement.

--

- Narrowly speaking, the Red Guards refer to .hi-slate[active high school student groups] that were based in different provinces in China from May to late 1966. Particularly, the Red Guards from colleges and were active at the late stage of the movement is labelled as “the rebels”.

--

- The Red Guards include all active from high school to college student groups in 1966, as well as a proportion of newly joined high school students after September 1966. .hi-slate[The widely-defined Red Guards population matches participating student groups at various stages of the Cultural Revolution].

---
layout: true
# Data
---
name:data


### The Source:
- This paper draws on the archive from Chinese Cultural Revolution Database (1966-1976) managed by the Chinese University of Hong Kong under the database named Databases for .hi-slate[the History of Contemporary Chinese Political Movements]. 
### 
&lt;img src="./images/database.png" width="52%" style="display: block; margin: auto;" /&gt;

--

### Selected Documents:
- Representative textual data include .hi-slate[tabloids (Xiaobao 小报)], .hi-slate[big-character posters (Dazibao 大字报)] and .hi-slate[party-related office documents]. 

---

### Big-character Posters (Dazibao 大字报): 
&lt;img src="./images/dazibao.png" width="80%" style="display: block; margin: auto;" /&gt;


---

### Tabloids (Xiaobao 小报):
&lt;img src="./images/xiabao.png" width="70%" style="display: block; margin: auto;" /&gt;

---

### Documents from the central officials:
&lt;img src="./images/offical_doc.png" width="45%" style="display: block; margin: auto;" /&gt;


---
&amp;nbsp;
&amp;nbsp;
&amp;nbsp;

### Table 2 describes the document records used in this paper
&lt;img src="./images/table2.png" width="100%" style="display: block; margin: auto;" /&gt;

---
layout: true
# Estimation Strategy
---
&amp;nbsp;

### The Rationale of the Methodolgy:

-  We seek to find an algorithm that serves two main functions: i) .hi-slate[extract key Chinese words and phrases (slogans)]; ii) .hi-slate[estimate the differences of spatial positions] using the extracted textual data. 

--

- To this end, we develop a new strain of .hi-slate[Wordfish algorithm] that takes advantage of the facilitation of TextRank algorithm to extract Chinese characters and phrases.

--

- The consideration of semantic structures of our proposed algorithm .hi-slate[mitigates the biasedness and errors] that are often found in the original Wordfish caused by .hi-slate[counting sole words] and .hi-slate[neglecting the linguistic contexts]. 

---
layout: true
# Keyword Extraction 
---

### UDpipe 

- UDPipe is capable of performing excellent parts of speech tagging such as .hi-slate[Universal POS tags] and .hi-slate[XPOS], .hi-slate[morphological features], and .hi-slate[syntactic dependencies], and syntactic analysis of CoNLL-U input based on .hi-slate[Universal Dependencies (UD) framework].

&lt;img src="./images/udpipe1.png" width="70%" style="display: block; margin: auto;" /&gt;

---

### UDpipe and UDpipe 2.5 Language Model
- we apply a pre-trained model from UDpipe, with .hi-slate[parts of speech (POS) tagging] and .hi-slate[linguistic dependencies], to tokenize the collected textual data(Straka, Hajič, and Straková 2016; Straka and Straková 2017), see https://ufal.mff.cuni.cz/udpipe/2.

&lt;img src="./images/udpipe2.png" width="60%" style="display: block; margin: auto;" /&gt;

---

### UD Chinese-GSDSimp Model

- The pre-trained model for NLP task is .hi-slate[UD Chinese-GSDSimp] (trained and contributed by Qi and Yasuoka 2020) and can be found at the authors' Github repository, at https://github.com/yl17124/UD_Chinese-GSDSimp. 

&lt;img src="./images/udpipe3.png" width="65%" style="display: block; margin: auto;" /&gt;


---

### The Concept of TextRank

- The first stage applies the TextRank algorithm that is commonly used in .hi-slate[automated keywords extraction techniques] of Natural Language Processing (NLP) to create a subset of words and phrases that represents the most important or relevant information by calculating the weight for each token within the document.

--

- In particular, .hi-slate[the tagging of linguistic features] can be utilized to extract important phrases and pair n-grams as noun phrases via keyword extraction techniques. 

---

&amp;nbsp;


- TextRank is .hi-slate[an unsupervised graph-based algorithm] for automated summarization of text containing keywords and initially introduced by Mihalcea and Tarau (2004) by converting Google's PageRank algorithms (Brin and Page 1998) into feature selection to extract certain phrases. 

--

- The ultimate goal of a keyword extraction is to effectively select a set of .hi-slate[representative terms] from the text that best describe and summarize the original document. 

--

- Therefore, these representative terms are the near-minimum information set that can be utilized for text classification, document collection and information summarization, from which .hi-slate[domain-specific dictionaries]are constructed. 

---
&amp;nbsp;
&amp;nbsp;

### The Flow of the TextRank

&lt;img src="./images/textrank.png" width="70%" style="display: block; margin: auto;" /&gt;
###### Source: https://www.analyticsvidhya.com/blog/2018/11/introduction-text-summarization-textrank-python/

---

### The Rationale and Concept of TextRank:

- TextRank reads original text as input and .hi-slate[ranks a sequence of single or multiple lexical units] extracted from the input, and these are hi-slate[stored as vertices] in the text graph. 

&lt;img src="./images/cooccurence.png" width="35%" style="display: block; margin: auto;" /&gt;

--

- We particularly define the property of .hi-slate[co-occurrence] as such relation between two .hi-slate[vertices]: a pair of lexical units are regarded as potentially linked .hi-slate[if they co-occur within a window of maximum n-grams (n is set to be 5 in our study)], and their representative vertices are linked in the text graph. 

---

#### Top 15 Keywords Identified by TextRank at Each Major Incident
&lt;img src="./images/keywords_p.png" width="55%" style="display: block; margin: auto;" /&gt;

---
layout: true
# Wordfish Scaling Model
---

### The Concept of Wordfish

- In the second stage, the algorithm estimates positions of each faction based on the .hi-slate[Poisson scaling model] proposed by Slapin and Proksch (2008). 

--

- The model produces the estimated positions by .hi-slate[analyzing frequencies of extracted keywords and phrases] from dictionaries constructed in the first stage. 
--

- The model takes the following functional form:

`$$y_{jm}\sim	Poisson(\theta_{jm}) \theta_{jm}=	exp(a_{m}+b_{j}+\beta_{j}*w_{i}^{m}),$$`
---
layout: true
# Analytical Findings
---
&amp;nbsp;
&amp;nbsp;

#### Figure 2: Smoothed Density Distribution of Estimated Positions for the Political Elite and the Red Gaurds

&lt;img src="./images/figure2.png" width="90%" style="display: block; margin: auto;" /&gt;


---
&amp;nbsp;

### Figure 3: Estimated Positions for Invidiual Member and Organizations in the Red Gaurds

&lt;img src="./images/rg_unique.png" width="50%" style="display: block; margin: auto;" /&gt;

---
&amp;nbsp;

### Figure 4: Estimated Positions for Zhou Enlai's Declation
&lt;img src="./images/first_incident.png" width="50%" style="display: block; margin: auto;" /&gt;

---
&amp;nbsp;

### Figure 5: Estimated Positions for the Announcement of New Public Security Regulations

&lt;img src="./images/second_incident.png" width="50%" style="display: block; margin: auto;" /&gt;

---
&amp;nbsp;
### Figure 6: Estimated Positions for February Countercurrent
&lt;img src="./images/third_incident.png" width="50%" style="display: block; margin: auto;" /&gt;


---
layout: true
# Takeways
---

&amp;nbsp;
&amp;nbsp;

#### Conclusion

- Estimation outcomes of ideological positions demonstrate that the majority of the Red Guards factions and the elite factions are .hi-slate[contrasting groups for most of time]. 

--

- This seems sensible and matches many evidences from previous literature (Walder and Su 2003; Wang 2019; Su 2006; Walder and Lu 2017; Walder 2016). However, .hi-slate[the position of these individual factions dynamically varied according to the development of incidents] and the shift of the political atmosphere. 

---

&amp;nbsp;

#### Contribution

- First, we augment TextRank so that we only care about .hi-slate[keywords and phrase] in each document and noisy terms have been filtered out before ideological position estimation. This is likely to .hi-slate[mitigate estimation error] due to less presence of the noise. 

--

- Second, different from many languages, Chinese speeches are .hi-slate[frequently phrase-based], rather than single word- (character-) based.

--

- TextRank is a graph-based algorithm that serves our purpose to interpret Chinese by extracting key phrases from texts. 

---
layout: false
class: inverse, center, middle

# Thank You
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
(function(time) {
  var d2 = function(number) {
    return ('0' + number).slice(-2); // left-pad 0 to minutes/seconds
  },

  time_format = function(total) {
    var secs = Math.abs(total) / 1000;
    var h = Math.floor(secs / 3600);
    var m = Math.floor(secs % 3600 / 60);
    var s = Math.round(secs % 60);
    var res = d2(m) + ':' + d2(s);
    if (h > 0) res = h + ':' + res;
    return res;  // [hh:]mm:ss
  },

  slide_number_div = function(i) {
    return document.getElementsByClassName('remark-slide-number').item(i);
  },

  current_page_number = function(i) {
    return slide_number_div(i).firstChild.textContent;  // text "i / N"
  };

  var timer = document.createElement('span'); timer.id = 'slide-time-left';
  var time_left = time, k = slideshow.getCurrentSlideIndex(),
      last_page_number = current_page_number(k);

  setInterval(function() {
    time_left = time_left - 1000;
    timer.innerHTML = ' ' + time_format(time_left);
    if (time_left < 0) timer.style.color = 'red';
  }, 1000);

  slide_number_div(k).appendChild(timer);

  slideshow.on('showSlide', function(slide) {
    var i = slide.getSlideIndex(), n = current_page_number(i);
    // reset timer when a new slide is shown and the page number is changed
    if (last_page_number !== n) {
      time_left = time; last_page_number = n;
      timer.innerHTML = ' ' + time_format(time); timer.style.color = null;
    }
    slide_number_div(i).appendChild(timer);
  });
})(30000);
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(images/LY_logo.svg);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 0.7em;
    right: 1em;
    width: 100px;
    height: 110px;
    z-index: 0;
  }
</style>
  
  <script>
  document
.querySelectorAll(
  '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
  // ':not(.inverse)' +
    ':not(.hide-logo)'
)
.forEach(el => {
  el.innerHTML += '<div class="logo"></div>';
});
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
